# В Ruby имеется богатый набор циклических конструкций. while и until - циклы с предварительной проверкой условия,
# и оба работают привычным образом: в первом случае задается условие продолжения цикла,
# а во втором - условие завершения. Есть также формы с модификатором, как для предложений if и unless.
# Кроме того, в модуле Kernel есть метод loop(по умолчанию бесконечный цикл), а в некоторых классах
# реализованы итераторы.
# В примерах ниже предполагается, что где-то определен такой массив list:

list = %w[alpha bravo charlie delta echo]

# В цикле этот массив обходится и печатается каждый его элемнт.

i = 0 # Цикл 1 (while)
while i < list.size do
	print "#{list[i]}"
	i += 1
end

i = 0 # Цикл 2 (until)
until i == list.size do
	print "#{list[i]}"
	i += 1
end

i = 0 # Цикл 3 (while с проверкой в конце)
begin
	print "#{list[i]}"
	i += 1
end while i < list.size

i = 0 # Цикл 4 (until с проверкой в конце)
begin
	print "#{list[i]}"
	i += 1
end until i == list.size

for x in list do # Цикл 5 (for)
	print "#{x} "
end

list.each do |x| # Цикл 6 (итератор 'each')
	print "#{x} "
end

i = 0 # Цикл 7 (метод 'loop')
n = list.size-1
loop do 
	print "#{list[i]}"
	i += 1
	break if i > n
end

i = 0 # Цикл 8 (метод 'loop')
n = list.size-1
loop do
	print "#{list[i]}"
	i += 1
	break unless i <= n
		
	end

n = list.size # Цикл  9 (итератор 'times')
n.times do |i|
	print "#{list[i]}"
end

n = list.size-1 # Цикл 10 (итератор 'upto')
0.upto(n) do |i|
	print "#{list[i]}"
end

n = list.size-1 # Цикл 11 (for)
for i in 0..n do
	print "#{list[i]}"
end

list.each_index do |x| # Цикл 12 (итератор 'each_index')
	print "#{list[i]}"
end

# Рассмотрим эти примеры более подробно. Циклы 1 и 2 - "стандартные" формы
# циклов while и until; ведут они себя практически одинаково, только условия противоположны.
# Циклы 3 и 4 - варианты предыдущих с проверкой условия в конце, а не
# в начале итерации. Отметим, что использование слов begin и end в этом контексте
# просто грязный трюк; на самом деле это был бы блок begin/end (применяемый для
# обработки исключений), за которым следует модификатор while или until. Иначе
# говоря, эта конструкция приведена только для иллюстрации. Не пишите так.
# На мой взгляд, цикл 6 - самый «правильный􀂧 способ кодирования циклов. Обратите
# внимание, насколько циклы 5 и 6 проще всех остальных; в них нет ни явной
# инициализации, ни явной проверки или инкремента. Это возможно потому,
# что массив "знает" свой размер, а стандартный итератор each (цикл 6) обрабатывает
# такие детали автоматически. На самом деле в цикле 3 просто производится
# неявное обращение к этому итератору, поскольку цикл for работает с любым объектом,
# для которого определен итератор each. Цикл for - всего лишь другой способ
# обращения к each
# В циклах 7 и 8 используется конструкция loop. Выше мы уже отмечали, что хотя
# loop выглядит как ключевое слово, которое начинает управляющую конструкцию,
# на самом деле это метод модуля Kernel.
# В циклах 9 и 1 О используется тот факт, что у массива есть числовой индекс. Итератор
# times исполняется заданное число раз, а итератор upto увеличивает свой параметр
# до заданного значения. И тот, и другой для данной ситуации приспособлены
# плохо.
# Цикл 11 - это вариант цикла for, предназначенный специально для работы со
# значениями индекса, заданными с помощью диапазона. В цикле 12 мы пробегаем
# весь диапазон индексов массива с помощью итератора each_index.

# В предыдущих примерах мы уделили недостаточно внимания вариантам циклов
# while и loop с модификаторами. Они довольно часто используются благодаря
# своей краткости. Вот еще два примера, в которых делается одно и то же:

perform_task() until finished

perform_task() while not finished

# Также приведенные примеры недостаточно ясно показывают, что циклы не всегда
# выполняются от начала до конца. Число итераций и момент завершения цикла
# не всегда предсказуемы. Нужны дополнительные средства управления циклами.
# Первое из них - ключевое слово break, встречающееся в циклах 7 и 8. Оно 110-
# зволяет досрочно выйти из цикла; в случае вложенных циклов происходит выход
# из самого внутреннего. Для программистов на С это интуитивно очевидно.
# Ключевое слово redo - обобщение retry на циклы общего вида. Оно работает
# в циклах while и until, как retry в итераторах.
# Ключевое слово next осуществляет переход на конец самого внутреннего цикла
# и возобновляет исполнение с этой точки. Работает для любого цикла и итератора.
# Как мы только что видели, итератор -- важное понятие в Ruby. Но следует отметить,
# что язык позволяет определять и пользовательские итераторы, не ограничиваясь
# встроенными.
# Стандартный итератор для любого объекта называется each. Это существенно
# отчасти из-за того, что позволяет использовать цикл for. Но итераторам можно давать
# и другие имена и применять для разных целей.
# С помощью yield можно также передать параметры, которые будут подставлены
# в список параметров блока (между вертикальными черточками). В следующем
# искусственном примере итератор всего лишь генерирует целые числа от 1 до 1 О,
# а вызов итератора порождает кубические степени этих чисел:

def my_sequence
	(1..10).each do |i|
		yield i
	end
end

my_sequence {|x| puts x**3}

# Отметим, что вместо фигурных скобок, в которые заключен блок, можно написать
# ключевые слова do и end. Различия между этими формами есть, но довольно
# тонкие.