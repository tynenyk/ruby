# Исключения - это механизм обработки ошибок.

# Предложение raise возбуждает исключение. Отметим, что raise - не зарезервированное слово, а метод модуля Kernel.
# (у него есть синоним fail.)

raise 							# Пример 1
raise "Произошла ошибка" 				# Пример 2
raise ArgumentError 					# Пример 3
raise ArgumentError, "Неверные значения" 		# Пример 4
raise ArgumentError.new("Неверные данные") 		# Пример 5
raise ArgumentError, "Неверные данные", caller[0] 	# Пример 6

# В примере 1 повторно возбуждается последнее встретившееся исключение.
# В примере 2 создается исключение RuntimeError, которому передается сообщение "Произошла ошибка".
# В примере 3 возбуждается исключение типа ArgumentError.
# В примере 4 такое же исключение, но с сообщением "Неверные данные".
# В примере 5 просто другая запись примера 4.
# В примере 6 еще добавляется трассировочная информация вида "filename:line" или "file:line:in 'method'"
# (хранящаеся в массиве caller).

# Для обработки исключений в Ruby служит блок begin-end. В простейшей форме внутри него нет ничего, кроме кода:

begin
	# Ничего полезного
	# ...
end

# Просто перехватывать ошибки не очень осмысленно. Но у блока может быть один или несколько обработчиков rescue.
# Если произойдет ошибка в любой точке программы между begin и rescue, то управление сразу будет передано
# в подходящий обработчик rescue.

begin
	x = Math.sqrt(y/z)
	# ...
rescue ArgumentError
	puts "Ошибка при извлечении квадратного корня."
rescue ZeroDivisionError
	puts "Попытка деления на нуль."
end

# Того же эффекта можно достичь слудующим образом:

begin
	x = Math.sqrt(y/z)
	# ...
rescue => err
	puts err
end

# Здесь в переменной err хранится объект-исключение; 
# Отметим, что кольскоро тип ошибки не указан, то этот оброботчик rescue будет перехватывать все исключения,
# производные от класса StandardError. В конструкции rescue => variable можно перед символом => дополнительно
# указать тип ошибки.

# Если типы ошибок указаны, то может случиться так, что тип реально возникшего исключения не совпадает
# ни с одним из них. На этот случай после всех обработчиков rescue разрешается поместить ветвь else.

begin
	# Код, в котором может возникнуть ошибка...
rescue Type 1
	# ...
rescue Type 2
	# ...
else
	# Прочие исключения...
end

# Часто мы хотим каким-то образом восстановиться после ошибки. В этом поможет ключевое слово retry.
# (внутри тела обработчика rescue). Оно позволяет повторно войти в блок begin и попытаться ещё раз 
# выполнить операцию:

begin
	# Код, в котором может возникнуть ошибка...
rescue
	# Пытаемся восстановиться...
	retry # Попробуем ещё раз
end

# Наконец, иногда необходим код, который "подчищает" что-то после выполнения блока begin-end. В этом
# случае можно добавить часть ensure:

begin
	# Код, в котором может возникнуть ошибка...
rescue
	# Обработка исключений
ensure
	# Этот код выполняется в любом случае
end

# Код, помещенный внутрь части ensure, выполняется при любом способе выхода из блока begin-end - произошло
# исключение или нет.
# Исключения можно перехватывать ещё двумя способами. Во-первых, существует форма rescue в виде модификатора: 

x = a/b rescue puts ("Деление на нуль")

# Кроме того, тело определения метода представляет собой неявный блок begin-end; слово begin опущено,
# а все тело метода подготовлено к обработке исключения и завершается словом end:

def some_method
	# Код
rescue
	# Восстановление после ошибки...
end

# На этом мы завершаем как обсуждение обработки исключений, так и рассмотрение основ синтаксиса и семантики в целом.


